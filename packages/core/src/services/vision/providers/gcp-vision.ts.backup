import { ImageAnnotatorClient } from '@google-cloud/vision';
import type { VisionProvider, VisionResult, GCPVisionResult } from '../types.js';

export class GCPVisionProvider implements VisionProvider {
  private client: ImageAnnotatorClient;
  private brandKeywords: Set<string>;

  constructor() {
    const credentialsJson = process.env.GOOGLE_APPLICATION_CREDENTIALS_JSON;
    
    if (credentialsJson) {
      const credentials = JSON.parse(Buffer.from(credentialsJson, 'base64').toString());
      this.client = new ImageAnnotatorClient({
        credentials,
        projectId: credentials.project_id || process.env.GOOGLE_PROJECT_ID
      });
    } else {
      // Fall back to default credentials (for local development)
      this.client = new ImageAnnotatorClient();
    }

    this.brandKeywords = new Set();
  }

  async analyzeImage(imageUrl: string, brandKeywords: string[]): Promise<VisionResult> {
    this.brandKeywords = new Set(brandKeywords.map(k => k.toLowerCase()));

    try {
      const [logoResult] = await this.client.logoDetection({ image: { source: { imageUri: imageUrl } } });
      const [labelResult] = await this.client.labelDetection({ image: { source: { imageUri: imageUrl } } });

      const gcpResult: GCPVisionResult = {
        logoMatch: false,
        confidence: 0,
        logoAnnotations: logoResult.logoAnnotations || [],
        labelAnnotations: labelResult.labelAnnotations || []
      };

      return this.processGCPResult(gcpResult);
    } catch (error) {
      console.error('GCP Vision API error:', error);
      return {
        logoMatch: false,
        confidence: 0,
        labels: [],
        explanations: [`Error analyzing image: ${error}`]
      };
    }
  }

  private processGCPResult(result: GCPVisionResult): VisionResult {
    const labels: string[] = [];
    const explanations: string[] = [];
    let maxConfidence = 0;
    let logoMatch = false;

    // Process logo annotations
    for (const logo of result.logoAnnotations) {
      labels.push(logo.description);
      
      if (this.isBrandMatch(logo.description)) {
        logoMatch = true;
        maxConfidence = Math.max(maxConfidence, logo.score);
        explanations.push(`Logo detected: ${logo.description} (${(logo.score * 100).toFixed(1)}%)`);
      }
    }

    // Process label annotations for brand-related terms
    for (const label of result.labelAnnotations) {
      labels.push(label.description);
      
      if (this.isBrandMatch(label.description)) {
        logoMatch = true;
        maxConfidence = Math.max(maxConfidence, label.score * 0.8); // Slightly lower confidence for labels vs logos
        explanations.push(`Brand-related label: ${label.description} (${(label.score * 100).toFixed(1)}%)`);
      }
    }

    return {
      logoMatch,
      confidence: maxConfidence,
      labels,
      explanations
    };
  }

  private isBrandMatch(text: string): boolean {
    const lowerText = text.toLowerCase();
    
    for (const keyword of this.brandKeywords) {
      if (lowerText.includes(keyword) || this.fuzzyMatch(lowerText, keyword)) {
        return true;
      }
    }
    
    return false;
  }

  private fuzzyMatch(text: string, keyword: string): boolean {
    const threshold = 0.8;
    const distance = this.levenshteinDistance(text, keyword);
    const similarity = 1 - distance / Math.max(text.length, keyword.length);
    return similarity >= threshold;
  }

  private levenshteinDistance(str1: string, str2: string): number {
    const matrix = [];

    for (let i = 0; i <= str2.length; i++) {
      matrix[i] = [i];
    }

    for (let j = 0; j <= str1.length; j++) {
      matrix[0][j] = j;
    }

    for (let i = 1; i <= str2.length; i++) {
      for (let j = 1; j <= str1.length; j++) {
        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {
          matrix[i][j] = matrix[i - 1][j - 1];
        } else {
          matrix[i][j] = Math.min(
            matrix[i - 1][j - 1] + 1,
            matrix[i][j - 1] + 1,
            matrix[i - 1][j] + 1
          );
        }
      }
    }

    return matrix[str2.length][str1.length];
  }
}
